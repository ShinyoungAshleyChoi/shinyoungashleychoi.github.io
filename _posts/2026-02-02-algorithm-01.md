---
layout: post
title: [알고리즘] 재귀, 조열, 순열, 정렬알고리즘
tags: ["algorithm"]
---

### 알게된 내용 정리

<aside>
💡

스터디 중 알게된 내용을 이론, 문법 중심으로 정리합니다.

</aside>

- 재귀 함수
    - 자기 자신을 호출하는 함수
    - Base Case: 재귀 함수를 종료하는 부분
        - Base Case가 없다면 무한 뤂에 빠질 수 있다
        - Recursive Case의 마지막 부분이라고 생각하면 쉽게 작성 가능하다.
    - Recursive Case: 자기 자신을 호출 하는 부분
- 조합과 순열
    - 조합(Combination): 순서 X
    - 순열(Permutation):  순서 O
    - 조합과 순열의 관계: nCr에 의 모든 경우에 대해 나열(순서)하면 된다
    - 재귀로 구현 가능
- 정렬 알고리즘
    - 브루트포스: 모든 경우 살펴보기
    - 그리디: 매순간 최선의 선택
    - DP: 복잡한 문제를 여러개의 문제로 나눔

### 문제 풀이

<aside>
💡

문제 풀이를 정리합니다.

</aside>

- 문제1 -  BOJ107
    - **유형: #재귀 #피보나치**
    - **난이도(선택):**
    - **시간복잡도**
        - O(n^2)
    - **아이디어**
        - **핵심 풀이 아이디어:** 문제에 다 나와있지만 와닿지 않아서 숫자를 다 대입해봄
        - **사고 과정**

            ```
            1. 대입
            	n == 0: 0,
            	n == 1: 1
            	n == 2: 0+1
            	n == 3: 1+1 (2)
            	n == 4: 1+2 (3)
            	n == 5: 2+3 (5)
            	n == 6: 5+3 (8) == f(5) + f(4) == (f(4)+f(3)) + (f(3)+f(2))
            		== ((f(3)+f(2))+(f(2)+f(1))+(f(2)+f(1))+f(1)+f(0)
            		== .....
            		==

            2. 규칙 발견
            	F(n) = F(n-1) + F(n-2)
            3. Base Case
            	n==0, n==1
            ```

        - **엣지 케이스(선택):**
    - **구현 순서**
    - **구현 코드**

        ```python
        def fibo(n):
        	if n <= 1:
        		return n
        	return fibo(n-1) + fibo(n-2)
        ```

    - **회고: 메모이제이션을 사용하면 시간복잡도를 줄일 수 있다.**

        ```python
        def fibo(x):
        	global lst

        	if lst[x] != -1:
        		return lst[x]

        	lst[x] = fibo(x-1) + fibo(n-2)
        	return lst[x]

        lst = [-1] * (n+2)
        lst[0] = 0
        lst[1] = 1

        x = int(input())
        print(fibo(x))

        # O(n)
        ```

- 문제2 - BOJ6603 (https://www.acmicpc.net/problem/6603)
    - **유형:** #조합 #재귀
    - **난이도(선택):**
    - **시간복잡도**
        - 최악의 경우 13C6 → O(n)
    - **아이디어**
        - **핵심 풀이 아이디어:** kC6, 재귀를 활용
        - **사고 과정:**
            - Base Case: level == r
            - Recursive Case: 하나씩 뽑기 반복
        - **엣지 케이스(선택):**
    - **구현 순서**
    - **구현 코드**

        ```python
        def solution(index, level):
        	global choose, lst, k

        	if level == 6:
        		for n in choose:
        			print(n, end=' ')
        		print()
        		return

        	for i in range(index, k):
        		choose.append(lst[i])
        		solution(i+1, level+1)
        		choose.pop()

        while True:
        	choose = []
        	I = list(map(int, input().split()))

        	k = I[0]
        	lst = I[1:]
        	if k == 0:
        		break

        	solution(0, 0)
        	print()
        ```

    - **회고:**
- 문제3 - BOJ10974
    - **유형:** #순열 #재귀
    - **난이도(선택):**
    - **시간복잡도**
        - O(NlogN)
    - **아이디어**
        - **핵심 풀이 아이디어:** 재귀를 활용
        - **사고 과정:**
            - Base Case: N개를 고르는 경우
            - Recursive Case:
        - **엣지 케이스(선택):**
    - **구현 순서**
    - **구현 코드**

        ```python
        def solution(level):
            global N, choose, check

            if level == N:
                print(' '.join(map(str, choose)))
                return

            for i in range(1, N + 1):
                if check[i] is True:
                    continue

                choose.append(i)
                check[i] = True

                solution(level + 1)

                check[i] = False
                choose.pop()

        N = int(input())
        choose = []
        check = [False] * (N + 1)

        solution(0)
        ```

    - **회고:**
- 문제4 - BOJ11650
    - **유형:** #정렬
    - **난이도(선택):**
    - **시간복잡도**
        - 1 ≤ N ≤ 100 → NlogN < 1억
        - O(NlogN)
    - **아이디어**
        - **핵심 풀이 아이디어: 정렬**
        - **사고 과정:**
            1. 곱한 순으로 정렬 → 더한 순으로 정렬
        - **엣지 케이스(선택):**
    - **구현 순서**
    - **구현 코드**

        ```java
        N = int(input())

        ranks = [list(map(int, input().split()))for _ in range(N)]
        ranks = sorted(
        	ranks,
        	key=lambda x: (x[1]*x[2]*x[3], x[1]+x[2]+x[3], x[0])
        )

        for rank in ranks[:3]:
        	print(rank[0], end=' ')
        ```

    - **회고:** 입출력 형식 맞추는 것이 킹받는다