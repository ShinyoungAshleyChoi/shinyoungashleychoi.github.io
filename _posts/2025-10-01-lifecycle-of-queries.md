---
layout: post
title: Understanding Apache Iceberg (4-1) - Lifecycle of Write Queries
tags: ["iceberg", "bigdata", "datalake"]
---

_이 글의 내용은 Apache Iceberg: The Definite Guide (O'Reily)의 내용을 정리한 것 입니다._

사족을 붙이자면, 이 부분을 어떻게 정리하는게 좋을까 하다가 그냥 읽고만 넘어갔었고 기억은 자연스레 휘발되었다..
결국 면접에서 해당 부분에 대한 질문에 대답을 못한 기념으로 아무렇게나 정리해본다.....^^


# Recap of Architecture of Apache Iceberg

| ![Apache Iceberg's components](/img/posts/2025-10-01-icberg-components.png) |
  |:-------------------------------------------------------------------------------------------------:|
|                            Apache Iceberg의 컴포넌트                             |


지난 포스트를 쓴지 오래 되었으니 복습부터 시작해보자!

## 카탈로그 레이어
- 카탈로그는 현(최신) 시점의 각 테이블의 메타데이터 파일을 가리킨다.
- 읽기든 쓰기든 첫 시작은 바로 이 카탈로그에서 최신 테이블의 상태를 확인하는 것으로 시작된다.

## 메타데이터 레이어
- 쿼리 엔진이 아이스버그 테이블에 뭔가를 쓸 때, 메타데이터 파일이 원자적으로 생성되며 최신 상태로 갱신된다. 이는 동시 쓰기와 같은 상황에서 테이블 커밋 기록을 선형적으로 유지할 수 있게 해준다.
- 읽기 시에는 쿼리 엔진은 항상 테이블의 최신버전을 바라보게 되는데, 이때 매니페스트 리스트를 통해 현재 파티션 스펙을 확인해서 불필요한 매니페스트 파일을 건너 뛸 수 있도록 한다.
- 매니페스트 파일의 통계정 보를 통해 파일 프루닝이 가능하다.

## 데이터 레이어
- 읽기 시에는 쿼리 엔진이 메타데이터 파일을 통해 어떤 데이터 파일을 읽을 것인지 거른다.
- 쓰기 시에는 저장소에 데이터 파일을 쓰고 그에 따라 메타데이터 파일들이 생성되고 업데이트 된다.


# 아이스버그의 쓰기 쿼리들!
- 쓰기 동작은 기본적으로 아래 프로세스를 거친다.
- |  ![Overview of the Apache Iceberg write process](/img/posts/2025-10-01-overview-of-write-process.png) |
    |:-------------------------------------------------------------------------------------------------:|
  |                                        Apache Iceberg 쓰기 프로세스                                        |

1. 엔진에서 쿼리 파싱
2. 일관성과 무결성을 유지 + 정해진 파티션 전략에 따라 데이터 쓰기 위해 카탈로그를 참조
3. 데이터 파일과 메타데이터 파일이 쿼리 기반으로 쓰여짐
4. 카탈로그 파일이 최신 메타데이터를 반영해 업데이트됨, 이후의 읽기 동작 시 최신 데이터를 바라볼 수 있도록.

5. 여러가지 시나리오들을 통해 더 들여자 보자.


## 시나리오1: 테이블 생성
```sql
CREATE TABLE orders (
    order_id BIGINT,
  customer_id BIGINT,
  order_amount DECIMAL(10, 2),
  order_ts TIMESTAMP
)
USING iceberg
PARTITIONED BY (HOUR(order_ts))
```
* 모든 쿼리는 spark sql 기준

1. 엔진에 쿼리 보내기
   - 쿼리 엔진에서 쿼리를 파싱
   - 이 경우 테이블 생성 쿼리이므로 엔진은 테이블을 생성하고 정의하겠쥬 (당연한 말)
2. 메타데이터 파일 쓰기
   - 테이블 경로에 v1.metadata.json 이라는 제목의 메터데이터 파일을 생성 시작
   - 이 메타데이터 파일에서 orders 테이블의 스키마를 정의
   - table-uuid 필드에 유니크한 식별자 저장
   - 현재는 실 데이터가 없기 때문에 해당 메타데이터는 추적할 매니페스트 리스트도, 파일도 없음
   - 아래는 우리가 작성한 테이블 생성문에 따른 최초의 메타데이터 파일 내용!
 ```json
 {
  "table-uuid": "072db680-d810-49ac-935c-56e901cad686",
  "schema": {
    "type": "struct",
    "schema-id": 0,
    "fields": [{
      "id": 1,
      "name": "order_id",
      "required": false,
      "type": "long"
    }, {
      "id": 2,
      "name": "customer_id",
      "required": false,
      "type": "long"
    }, {
      "id": 3,
      "name": "order_amount",
      "required": false,
      "type": "decimal(10, 2)"
    }, {
      "id": 4,
      "name": "order_ts",
      "required": false,
      "type": "timestamptz"
    }],
    "partition-spec": [{
      "name": "order_ts_hour",
      "transform": "hour",
      "source-id": 4,
      "field-id": 1000
    }]
  }
 } 
```
3. 변경 사항을 저장하기 위해 카탈로그 파일 업데이트 하기
   - 쿼리 엔진이 카탈로그 파일인 version-hint.text에 현재 시점의 메타데이터 포인터를 v1.metadata.json으로 업데이트

## 시나리오2: 쓰기 쿼리
```sql
INSERT INTO orders VALUES (
                           123,
                           456,
                           36.17,
                           '2023-03-07 08:10:23'
                          )
```
1. 엔진에 쿼리 보내기 (쿼리 파싱)
2. 카탈로그 확인
   - 쿼리 엔진이 가장 처음 하는 일은 카탈로그에 현재 메타데이터 파일의 위치를 요청하고 그것을 읽는 것!
   - 엔진은 /orders/metadata/version-hint.txt 의 파일 내용인 1을 확인한다. (경로는 하둡 카탈로그 기준)
   - 2번을 통해 엔진은 현재 메타데이터 파일의 위치가 /orders/metadata/v1.metadata.json임을 알게되고 이를 읽는다.
3. 데이터 파일과 메타데이터 파일 쓰기
   - 엔진이 스키마와 파티셔닝 정보를 알게 되면 새로운 데이터 파일과 이와 관련된 메타데이터 파일을 작성하기 시작한다.
   - 데이터 파일을 작성하고 나서 엔진은 매니페스트 파일을 생성한다. 이 매니페스트 파일(avro파일)은 실제 데이터 파일의 경로에 대한 정보, 통계 정보를 담고 있다.
   - 매니페스트 파일 예시는 이전 글을 참고해보세요..
   - 다음으로는 메니페스트 파일을 추적하는 매니페스트 리스트를 생성한다. 이미 현재 스냅샷의 매니페스트 파일이 존재한다면 이 파일들은 새로운 매니페스트 리스트에 추가된다.
   - 매니페스트 리스트는 데이터 파일의 개수, 추가되거나 삭제된 로우 수, 파티션에 대한 통계정보등을 담는다.
   - 매니페스트 리스트 예시도 이전 글의 링크를 참조..
   - 마지막으로 엔진은 새로운 스냡샷 s1과 함께, 새로운 메타데이터 파일, 즉, v2.metadata.json을 생성한다. 이전의 v1.metadata.json은 s0 스냡샷을 추적했다.
   - 이 새로운 메타데이터 파일은 매니페스트 리스트 위치, 스냡샷 ID, 오퍼레이션 요약 정보 등 매니페스트 리스트에 대한 정보를 담고 있다.
   - 메타데이터 파일 예시도.....예
4. 변경 사항 저장을 위한 카탈로그 파일 업데이트 하기
   - 카탈로그로 다시 돌아가, 이 쓰기 작업 수행 시에 동안 다른 스냡샷이 커밋되지는 않았는지 확인한다. - 아이스버그에서 동시 쓰기를 보장하는데에 핵심인 부분..!
   - 낙관적 동시성 제어에 따라 아이스버그는 쓰기 커밋이 이루어지기 전까지 쓰기 충돌이 없다고 가정하고 새 메타데이터 파일을 생성한다.
   - 새 버전의 메타데이터 파일로 원자적으로 포인터를 스위치한다.


## 시나리오3: Merge 쿼리 (upsert)
``sql
MERGE INTO orders o
USING (SELECT * FROM orders_staging) s
ON o.order_id = s.,order_id
WHEN MATCHED THEN UPDATE SET order_amount = s.order_amount
WHEN NOT MATCHED THEN INSERT *
``
1. 엔진에 쿼리 보내기 (쿼리 파싱)
   - 쿼리에 있는 두 개의 테이블에 대해 실행 계획을 세움
2. 카탈로그 확인
   - 위 쓰기 쿼리와 마찬가지로 카탈로그에 현재 메타데이터 파일의 위치를 확인하고 그 파일을 읽음
   - version-hint.txt에서 정수값 2를 확인 한다. 즉, 현재 메타데이터 파일의 위치는 /orders/metadata/v2.metadata.json임을 알게된다.
   - 이 메타데이터 파일을 통해 테이블의 최신 스키마를 확인하고 쓰기 작업이 스키마에 맞게 수행되도록 한다.
   - 마지막으로 엔진은 파티셔닝 전략에 따라 데이터 파일들이 어떻게 구성되어 있는지를 파악하고 데이터 파일 쓰기를 시작한다.
3. 데이터 파일과 메타데이터 파일 쓰기
   - orders_staging과 orders테이블의 데이터를 메모리에 로드하여 서로 일치하는 레코드를 찾는다.
   - 아이스버그는 두가지 쓰기 전략 즉, COW(copy-on-write)와 MOR(merge-on-read)를 사용한다.
     - COW는 아이스버그 테이블 갱신시 관련된 데이터 파일을 새로 작성한다. (높은 쓰기 오버에드/낮은 읽기 오버헤드)
     - MOR전략에서는 기존 파일을 다시 쓰지 않고 변경된 내용을 추적하기 위한 새로운 delete 파일을 생성한다. (낮은 쓰기 오버헤드/높은 읽기 오버헤드)
   - 이번 예제에서는 COW전략을 사용한다고 가정.
   - orders테이블에 있는 order_id = 123 을 포함한 데이터 파일 0_0_0.parquet 을 메모리로 읽어온다.
   - order_staging 테이블의 새로운 order_amount 값으로 order_id = 123의 order_amount필드를 갱신한다.
   - 수정된 결과는 새로운 parquet파일로 기록된다.
   - COW 전략을 사용한다고 가정했기 떄문에 쿼리 조건과 일치 하지 않는 레코드들 또한 새 데이터 파일에 (변경없이) 기록된다.
   - order_staging테이블에서 조건에 맞지 않았던 레코드는 일반적인 INSERT로 처리 되어 새로운 파티션에 새로운 데이터 파일로 작성된다.
   - 데이터 파일을 작성한 후 엔진은 두 개의 데이터 파일 경로를 참조하는 새로운 메니페스트 파일을 생성한다. (메니페스트 파일은 뭐다? 데이터 파일의 통계정보를 담은 파일!)
   - 이후 엔진은 방금 생성한 메니페스트 파일을 가리키는 새로운 매니페스트 리스트를 생성한다. 이 리스트에는 기존의 메니세프슽 파일들도 함꼐 추적된다. (메니페스트 리스트에는 파티션 통계나 추가/삭제된 파일의 수 같은 정보 포함)
   - 그 후 엔진은 새로운 스냅샷(s2)를 포함하는 새로운 메타데이터 파일 v3.metadata.json을 생성한다.
   - 이 파일은 이전 메타데이터 파일인 v2.metadata.json을 기반으로 하며 그 안에는 이전 스냡샷 (s0, s1)도 함꼐 포함된다.
4. 변경 사항 저장을 위한 카탈로그 파일 업데이트
   - 마지막으로 엔진은 다시한 번 쓰기 충돌이 없는지 겅증한 뒤 최신 메타데이터 파일 (v3.metadata.json)로 카탈로그를 업데이트 한다.


| ![Iceberg Components hierachy after executing MERGE INTO](/img/posts/2025-10-01-query-result.png) |
  |:-------------------------------------------------------------------------------------------------:|
|                                         Merge Into 실행한 결과                                         |

