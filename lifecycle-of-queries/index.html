<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Developer's Delight</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="shortcut icon" href="/img/favicon.png">
</head>
<body>

<!-- 블로그 제목을 항상 보이게 고정 -->
<header class="site-header">
    <h1 class="site-title">
        Developer's Delight
    </h1>
</header>

<div class="container">
    <div class="sidebar">
    <a href="/" class="logo">
        <img src="/img/favicon.png">
    </a>
    <ul class="nav">
        <div class="nav-inner">
            <li><a href="/about/"><span class="icon info"></span>about</a></li>
            <li><a href="/search/"><span class="icon doc"></span>search</a></li>
            <li><a href="/tags/"><span class="icon code"></span>tags</a></li>
            <li><a href="http://github.com/shinyoungashleychoi"><span class="icon github"></span>github</a></li>
        </div>

    </ul>
</div>
    <div class="wrapper">
        <div class="post">
  <h1 class="post-title">Understanding Apache Iceberg (4-1) - Lifecycle of Write Queries</h1>
  <div class="post-meta">
    <p>Posted on October 01, 2025</p>
  </div>
  <div class="post-body">
    <p><em>이 글의 내용은 Apache Iceberg: The Definite Guide (O’Reily)의 내용을 정리한 것 입니다.</em></p>

<p>사족을 붙이자면, 이 부분을 어떻게 정리하는게 좋을까 하다가 그냥 읽고만 넘어갔었고 기억은 자연스레 휘발되었다..
결국 면접에서 해당 부분에 대한 질문에 대답을 못한 기념으로 아무렇게나 정리해본다…..^^</p>

<h1 id="recap-of-architecture-of-apache-iceberg">Recap of Architecture of Apache Iceberg</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/img/posts/2025-10-01-icberg-components.png" alt="Apache Iceberg's components" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Apache Iceberg의 컴포넌트</td>
    </tr>
  </tbody>
</table>

<p>지난 포스트를 쓴지 오래 되었으니 복습부터 시작해보자!</p>

<h2 id="카탈로그-레이어">카탈로그 레이어</h2>
<ul>
  <li>카탈로그는 현(최신) 시점의 각 테이블의 메타데이터 파일을 가리킨다.</li>
  <li>읽기든 쓰기든 첫 시작은 바로 이 카탈로그에서 최신 테이블의 상태를 확인하는 것으로 시작된다.</li>
</ul>

<h2 id="메타데이터-레이어">메타데이터 레이어</h2>
<ul>
  <li>쿼리 엔진이 아이스버그 테이블에 뭔가를 쓸 때, 메타데이터 파일이 원자적으로 생성되며 최신 상태로 갱신된다. 이는 동시 쓰기와 같은 상황에서 테이블 커밋 기록을 선형적으로 유지할 수 있게 해준다.</li>
  <li>읽기 시에는 쿼리 엔진은 항상 테이블의 최신버전을 바라보게 되는데, 이때 매니페스트 리스트를 통해 현재 파티션 스펙을 확인해서 불필요한 매니페스트 파일을 건너 뛸 수 있도록 한다.</li>
  <li>매니페스트 파일의 통계정 보를 통해 파일 프루닝이 가능하다.</li>
</ul>

<h2 id="데이터-레이어">데이터 레이어</h2>
<ul>
  <li>읽기 시에는 쿼리 엔진이 메타데이터 파일을 통해 어떤 데이터 파일을 읽을 것인지 거른다.</li>
  <li>쓰기 시에는 저장소에 데이터 파일을 쓰고 그에 따라 메타데이터 파일들이 생성되고 업데이트 된다.</li>
</ul>

<h1 id="아이스버그의-쓰기-쿼리들">아이스버그의 쓰기 쿼리들!</h1>
<ul>
  <li>쓰기 동작은 기본적으로 아래 프로세스를 거친다.</li>
  <li>
    <table>
      <thead>
        <tr>
          <th style="text-align: center"><img src="/img/posts/2025-10-01-overview-of-write-process.png" alt="Overview of the Apache Iceberg write process" /></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">Apache Iceberg 쓰기 프로세스</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<ol>
  <li>엔진에서 쿼리 파싱</li>
  <li>일관성과 무결성을 유지 + 정해진 파티션 전략에 따라 데이터 쓰기 위해 카탈로그를 참조</li>
  <li>데이터 파일과 메타데이터 파일이 쿼리 기반으로 쓰여짐</li>
  <li>
    <p>카탈로그 파일이 최신 메타데이터를 반영해 업데이트됨, 이후의 읽기 동작 시 최신 데이터를 바라볼 수 있도록.</p>
  </li>
  <li>여러가지 시나리오들을 통해 더 들여자 보자.</li>
</ol>

<h2 id="시나리오1-테이블-생성">시나리오1: 테이블 생성</h2>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">orders</span> <span class="p">(</span>
    <span class="n">order_id</span> <span class="nb">BIGINT</span><span class="p">,</span>
  <span class="n">customer_id</span> <span class="nb">BIGINT</span><span class="p">,</span>
  <span class="n">order_amount</span> <span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
  <span class="n">order_ts</span> <span class="nb">TIMESTAMP</span>
<span class="p">)</span>
<span class="k">USING</span> <span class="n">iceberg</span>
<span class="n">PARTITIONED</span> <span class="k">BY</span> <span class="p">(</span><span class="n">HOUR</span><span class="p">(</span><span class="n">order_ts</span><span class="p">))</span>
</code></pre></div></div>
<ul>
  <li>모든 쿼리는 spark sql 기준</li>
</ul>

<ol>
  <li>엔진에 쿼리 보내기
    <ul>
      <li>쿼리 엔진에서 쿼리를 파싱</li>
      <li>이 경우 테이블 생성 쿼리이므로 엔진은 테이블을 생성하고 정의하겠쥬 (당연한 말)</li>
    </ul>
  </li>
  <li>메타데이터 파일 쓰기
    <ul>
      <li>테이블 경로에 v1.metadata.json 이라는 제목의 메터데이터 파일을 생성 시작</li>
      <li>이 메타데이터 파일에서 orders 테이블의 스키마를 정의</li>
      <li>table-uuid 필드에 유니크한 식별자 저장</li>
      <li>현재는 실 데이터가 없기 때문에 해당 메타데이터는 추적할 매니페스트 리스트도, 파일도 없음</li>
      <li>아래는 우리가 작성한 테이블 생성문에 따른 최초의 메타데이터 파일 내용!
        <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="nl">"table-uuid"</span><span class="p">:</span><span class="w"> </span><span class="s2">"072db680-d810-49ac-935c-56e901cad686"</span><span class="p">,</span><span class="w">
</span><span class="nl">"schema"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"struct"</span><span class="p">,</span><span class="w">
 </span><span class="nl">"schema-id"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
 </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
 </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
 </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"order_id"</span><span class="p">,</span><span class="w">
 </span><span class="nl">"required"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
 </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"long"</span><span class="w">
 </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
 </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"customer_id"</span><span class="p">,</span><span class="w">
 </span><span class="nl">"required"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
 </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"long"</span><span class="w">
 </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">
 </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"order_amount"</span><span class="p">,</span><span class="w">
 </span><span class="nl">"required"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
 </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"decimal(10, 2)"</span><span class="w">
 </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w">
 </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"order_ts"</span><span class="p">,</span><span class="w">
 </span><span class="nl">"required"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
 </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"timestamptz"</span><span class="w">
 </span><span class="p">}],</span><span class="w">
 </span><span class="nl">"partition-spec"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
 </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"order_ts_hour"</span><span class="p">,</span><span class="w">
 </span><span class="nl">"transform"</span><span class="p">:</span><span class="w"> </span><span class="s2">"hour"</span><span class="p">,</span><span class="w">
 </span><span class="nl">"source-id"</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w">
 </span><span class="nl">"field-id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1000</span><span class="w">
 </span><span class="p">}]</span><span class="w">
</span><span class="p">}</span><span class="w">
 </span><span class="p">}</span><span class="w"> 
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>변경 사항을 저장하기 위해 카탈로그 파일 업데이트 하기
    <ul>
      <li>쿼리 엔진이 카탈로그 파일인 version-hint.text에 현재 시점의 메타데이터 포인터를 v1.metadata.json으로 업데이트</li>
    </ul>
  </li>
</ol>

<h2 id="시나리오2-쓰기-쿼리">시나리오2: 쓰기 쿼리</h2>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">orders</span> <span class="k">VALUES</span> <span class="p">(</span>
                           <span class="mi">123</span><span class="p">,</span>
                           <span class="mi">456</span><span class="p">,</span>
                           <span class="mi">36</span><span class="p">.</span><span class="mi">17</span><span class="p">,</span>
                           <span class="s1">'2023-03-07 08:10:23'</span>
                          <span class="p">)</span>
</code></pre></div></div>
<ol>
  <li>엔진에 쿼리 보내기 (쿼리 파싱)</li>
  <li>카탈로그 확인
    <ul>
      <li>쿼리 엔진이 가장 처음 하는 일은 카탈로그에 현재 메타데이터 파일의 위치를 요청하고 그것을 읽는 것!</li>
      <li>엔진은 /orders/metadata/version-hint.txt 의 파일 내용인 1을 확인한다. (경로는 하둡 카탈로그 기준)</li>
      <li>2번을 통해 엔진은 현재 메타데이터 파일의 위치가 /orders/metadata/v1.metadata.json임을 알게되고 이를 읽는다.</li>
    </ul>
  </li>
  <li>데이터 파일과 메타데이터 파일 쓰기
    <ul>
      <li>엔진이 스키마와 파티셔닝 정보를 알게 되면 새로운 데이터 파일과 이와 관련된 메타데이터 파일을 작성하기 시작한다.</li>
      <li>데이터 파일을 작성하고 나서 엔진은 매니페스트 파일을 생성한다. 이 매니페스트 파일(avro파일)은 실제 데이터 파일의 경로에 대한 정보, 통계 정보를 담고 있다.</li>
      <li>매니페스트 파일 예시는 이전 글을 참고해보세요..</li>
      <li>다음으로는 메니페스트 파일을 추적하는 매니페스트 리스트를 생성한다. 이미 현재 스냅샷의 매니페스트 파일이 존재한다면 이 파일들은 새로운 매니페스트 리스트에 추가된다.</li>
      <li>매니페스트 리스트는 데이터 파일의 개수, 추가되거나 삭제된 로우 수, 파티션에 대한 통계정보등을 담는다.</li>
      <li>매니페스트 리스트 예시도 이전 글의 링크를 참조..</li>
      <li>마지막으로 엔진은 새로운 스냡샷 s1과 함께, 새로운 메타데이터 파일, 즉, v2.metadata.json을 생성한다. 이전의 v1.metadata.json은 s0 스냡샷을 추적했다.</li>
      <li>이 새로운 메타데이터 파일은 매니페스트 리스트 위치, 스냡샷 ID, 오퍼레이션 요약 정보 등 매니페스트 리스트에 대한 정보를 담고 있다.</li>
      <li>메타데이터 파일 예시도…..예</li>
    </ul>
  </li>
  <li>변경 사항 저장을 위한 카탈로그 파일 업데이트 하기
    <ul>
      <li>카탈로그로 다시 돌아가, 이 쓰기 작업 수행 시에 동안 다른 스냡샷이 커밋되지는 않았는지 확인한다. - 아이스버그에서 동시 쓰기를 보장하는데에 핵심인 부분..!</li>
      <li>낙관적 동시성 제어에 따라 아이스버그는 쓰기 커밋이 이루어지기 전까지 쓰기 충돌이 없다고 가정하고 새 메타데이터 파일을 생성한다.</li>
      <li>새 버전의 메타데이터 파일로 원자적으로 포인터를 스위치한다.</li>
    </ul>
  </li>
</ol>

<h2 id="시나리오3-merge-쿼리-upsert">시나리오3: Merge 쿼리 (upsert)</h2>
<p><code class="language-plaintext highlighter-rouge">sql
MERGE INTO orders o
USING (SELECT * FROM orders_staging) s
ON o.order_id = s.,order_id
WHEN MATCHED THEN UPDATE SET order_amount = s.order_amount
WHEN NOT MATCHED THEN INSERT *
</code></p>
<ol>
  <li>엔진에 쿼리 보내기 (쿼리 파싱)
    <ul>
      <li>쿼리에 있는 두 개의 테이블에 대해 실행 계획을 세움</li>
    </ul>
  </li>
  <li>카탈로그 확인
    <ul>
      <li>위 쓰기 쿼리와 마찬가지로 카탈로그에 현재 메타데이터 파일의 위치를 확인하고 그 파일을 읽음</li>
      <li>version-hint.txt에서 정수값 2를 확인 한다. 즉, 현재 메타데이터 파일의 위치는 /orders/metadata/v2.metadata.json임을 알게된다.</li>
      <li>이 메타데이터 파일을 통해 테이블의 최신 스키마를 확인하고 쓰기 작업이 스키마에 맞게 수행되도록 한다.</li>
      <li>마지막으로 엔진은 파티셔닝 전략에 따라 데이터 파일들이 어떻게 구성되어 있는지를 파악하고 데이터 파일 쓰기를 시작한다.</li>
    </ul>
  </li>
  <li>데이터 파일과 메타데이터 파일 쓰기
    <ul>
      <li>orders_staging과 orders테이블의 데이터를 메모리에 로드하여 서로 일치하는 레코드를 찾는다.</li>
      <li>아이스버그는 두가지 쓰기 전략 즉, COW(copy-on-write)와 MOR(merge-on-read)를 사용한다.
        <ul>
          <li>COW는 아이스버그 테이블 갱신시 관련된 데이터 파일을 새로 작성한다. (높은 쓰기 오버에드/낮은 읽기 오버헤드)</li>
          <li>MOR전략에서는 기존 파일을 다시 쓰지 않고 변경된 내용을 추적하기 위한 새로운 delete 파일을 생성한다. (낮은 쓰기 오버헤드/높은 읽기 오버헤드)</li>
        </ul>
      </li>
      <li>이번 예제에서는 COW전략을 사용한다고 가정.</li>
      <li>orders테이블에 있는 order_id = 123 을 포함한 데이터 파일 0_0_0.parquet 을 메모리로 읽어온다.</li>
      <li>order_staging 테이블의 새로운 order_amount 값으로 order_id = 123의 order_amount필드를 갱신한다.</li>
      <li>수정된 결과는 새로운 parquet파일로 기록된다.</li>
      <li>COW 전략을 사용한다고 가정했기 떄문에 쿼리 조건과 일치 하지 않는 레코드들 또한 새 데이터 파일에 (변경없이) 기록된다.</li>
      <li>order_staging테이블에서 조건에 맞지 않았던 레코드는 일반적인 INSERT로 처리 되어 새로운 파티션에 새로운 데이터 파일로 작성된다.</li>
      <li>데이터 파일을 작성한 후 엔진은 두 개의 데이터 파일 경로를 참조하는 새로운 메니페스트 파일을 생성한다. (메니페스트 파일은 뭐다? 데이터 파일의 통계정보를 담은 파일!)</li>
      <li>이후 엔진은 방금 생성한 메니페스트 파일을 가리키는 새로운 매니페스트 리스트를 생성한다. 이 리스트에는 기존의 메니세프슽 파일들도 함꼐 추적된다. (메니페스트 리스트에는 파티션 통계나 추가/삭제된 파일의 수 같은 정보 포함)</li>
      <li>그 후 엔진은 새로운 스냅샷(s2)를 포함하는 새로운 메타데이터 파일 v3.metadata.json을 생성한다.</li>
      <li>이 파일은 이전 메타데이터 파일인 v2.metadata.json을 기반으로 하며 그 안에는 이전 스냡샷 (s0, s1)도 함꼐 포함된다.</li>
    </ul>
  </li>
  <li>변경 사항 저장을 위한 카탈로그 파일 업데이트
    <ul>
      <li>마지막으로 엔진은 다시한 번 쓰기 충돌이 없는지 겅증한 뒤 최신 메타데이터 파일 (v3.metadata.json)로 카탈로그를 업데이트 한다.</li>
    </ul>
  </li>
</ol>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/img/posts/2025-10-01-query-result.png" alt="Iceberg Components hierachy after executing MERGE INTO" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Merge Into 실행한 결과</td>
    </tr>
  </tbody>
</table>


  </div>
  <div class="post-end-block"></div>
</div>
    </div>
</div>

<script src="/search.js"></script>

</body>
</html>